version: '3.8'

# good to specify the project name for a more consistent resulting environment. For example, network names
# are prefixed by the compose file's project name https://docs.docker.com/compose/how-tos/networking/
name: iidi

networks:
  host-loopback:
    driver: bridge
    driver_opts:
      # the default docker bridge driver behaviour is to bind exposed ports on 0.0.0.0, making them accessible
      # from the local network. Not good, unless you're on a known-safe network (ha) and specifically want to
      # serve dev traffic from other local devices (e.g. testing on mobile devices).
      # Configuring this network to bind on loopback instead, so that only incoming traffic from the host machine
      # can reach our containers on their dev ports
      com.docker.network.bridge.host_binding_ipv4: '127.0.0.1'
  gateway:
    driver: bridge
    internal: true
  on-fhir-db:
    # If/when access is needed, run docker compose with a shell attached to the db cluster directly, don't open to host network
    driver: bridge
    internal: true
  on-bullmq-redis:
    # If/when access is needed, run docker compose with a shell attached to the db cluster directly, don't open to host network
    driver: bridge
    internal: true
  on-internal:
    driver: bridge
    internal: true
  bc-fhir-db:
    # If/when access is needed, run docker compose with a shell attached to the db cluster directly, don't open to host network
    driver: bridge
    internal: true
  bc-bullmq-redis:
    # If/when access is needed, run docker compose with a shell attached to the db cluster directly, don't open to host network
    driver: bridge
    internal: true
  bc-internal:
    driver: bridge
    internal: true
  federal-internal:
    driver: bridge
    internal: true

configs:
  gateway.default.conf:
    # Configure this to mock the behaviour of the /k8s cluster's gateway configuration
    # Note: double $'s (`$$`) below are escaped single $'s, to avoid docker compose variable interpolation
    content: |
      server {
          location /on/fhir/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://on-fhir:8080/fhir/;
          }
          location /on/aggregator/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://on-aggregator:5000/;
          }
          location /on/browser/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              # fix relative paths in returned HTML/JS/CSS
              # necessary for the patient browser as it doesn't let us directly configure a server root like the fhir servers do
              sub_filter_once off; sub_filter_types *;
              sub_filter '/assets' '/on/browser/assets';
              sub_filter '/images' '/on/browser/images';
              proxy_pass http://on-patient-browser:80/;
          }
          location /on/inbound/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://on-transfer-inbound:3000/;
          }
          location /on/outbound/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://on-transfer-outbound:3000/;
          }

          location /bc/fhir/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://bc-fhir:8080/fhir/;
          }
          location /bc/aggregator/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://bc-aggregator:5000/;
          }
          location /bc/browser/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              # fix relative paths in returned HTML/JS/CSS
              # necessary for the patient browser as it doesn't let us directly configure a server root like the fhir servers do
              sub_filter_once off; sub_filter_types *;
              sub_filter '/assets' '/bc/browser/assets';
              sub_filter '/images' '/bc/browser/images';
              proxy_pass http://bc-patient-browser:80/;
          }
          location /bc/inbound/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://bc-transfer-inbound:3000/;
          }
          location /bc/outbound/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://bc-transfer-outbound:3000/;
          }

          location /fed/federator/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://federator:3000/;
          }
          location /fed/dashboard/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://dashboard:3838/;
          }

          location / {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://demo-portal:8080/;
          }
          location /demo-transfer-dashboard/ {
              # set proxy headers
              proxy_set_header Host $$host;
              proxy_set_header X-Real-IP $$remote_addr;
              proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $$scheme;
              
              # WebSocket support
              proxy_http_version 1.1;
              proxy_set_header Upgrade $$http_upgrade;
              proxy_set_header Connection "upgrade";

              # prevent nginx from dropping the port from localhost urls
              absolute_redirect off;

              proxy_pass http://demo-transfer-dashboard:3005/demo-transfer-dashboard/;

              # This part's important. rspack dev server URIs are a mix of static content resources on the server and SPA routes.
              # If the dev server doesn't have a resource, then it must be assumed that URI is actually an SPA route,
              # so replace UI server 404's with the index.html, to load the SPA and let it handle the route client side.
              # In deployments, the static file server should itself use nginx with an equivalent config (using `try_file`,
              # but that's not an option when proxying). Direct requests to the rspack dev server also work as expected by default,
              # but not when proxied through nginx like this (nginx layers in its own 404 response by default)
              proxy_intercept_errors on;
              error_page 404 = /index.html;
          }
      }
  hapi:
    file: ./hapi-dev.application.yaml

services:
  gateway:
    image: nginx:1.27.3
    tty: ${DOCKER_TTY:-true}
    restart: always
    networks:
      - gateway
      - host-loopback
    ports:
      - 8080:80
    configs:
      - source: gateway.default.conf
        target: /etc/nginx/conf.d/default.conf

  on-fhir-db: &fhir-db-service
    image: postgres:14.11-alpine
    tty: ${DOCKER_TTY:-true}
    restart: always
    networks:
      - on-fhir-db
    ports:
      - 5432:5432
    environment: &fhir-db-env
      POSTGRES_DB: hapi-fhir-db
      POSTGRES_USER: hapi-fhir-db
      POSTGRES_PASSWORD: local-dev-value
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U hapi-fhir-db -d hapi-fhir-db']
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s
  on-fhir: &fhir-service
    image: hapiproject/hapi:latest
    tty: ${DOCKER_TTY:-true}
    restart: always
    networks:
      - gateway
      - on-fhir-db
      - on-internal
    ports:
      - 8080:8080
    configs:
      - source: hapi
        target: /app/config/application.yaml
    environment:
      # NOTE: the env vars below are interpolated in to the hapi application.yaml at run time
      # If you add any env vars for other purposes, put them above this comment, to keep track of things
      <<: *fhir-db-env
      DB_PORT: 5432
      DB_HOST: on-fhir-db
      FHIR_SERVER_ADDRESS: http://localhost:8080/on/fhir # see proxy address via gateway.default.conf
  on-synthesizer: &synthesizer-service
    image: synthesizer:1.1
    tty: ${DOCKER_TTY:-true}
    restart: on-failure # reattempt until successful
    build:
      context: ./synthesizer
    networks:
      - on-internal
    environment:
      NUM_RECORDS: 100
      PT: on
      FHIR_URL: http://on-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  on-aggregator: &aggregator-service
    image: aggregator:1.4
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./aggregator
    networks:
      - gateway
      - on-internal
    ports:
      - 5000:5000
    environment:
      AGGREGATION_INTERVAL: 60
      FHIR_URL: http://on-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  on-patient-browser: &patient-browser-service
    image: patient-browser:1.1
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./patient-browser
    networks:
      - gateway
      - on-internal
    ports:
      - 80:80
    environment:
      FHIR_URL: http://localhost:8080/on/fhir/ # in this case, resolved in the host browser, not container networking, see gateway.default.conf
  on-transfer-inbound: &transfer-inbound-service
    image: node-dev:1.0
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./node-dev-docker-env
      dockerfile: ./Dockerfile.node-dev
    volumes:
      - ./transfer-inbound:/home/node-dev/project
      - ./transfer-inbound/.env.node-dev-docker-env-overrides:/home/node-dev/project/.env
    command: npm run dev:${DOCKER_API_COMMAND:-docker} # 'docker' or 'docker-debug'
    networks:
      - gateway
      - on-internal
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      - 3001:3000
      - 9231:9229 # for the node debug server, when active; see node-dev-docker-env/package.json `dev:docker-debug` script
    environment:
      EXPRESS_PORT: 3000
      DEV_IS_LOCAL_ENV: True
      FHIR_URL: http://on-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  on-bullmq-redis: &bullmq-redis
    image: redis:7.4.1-alpine
    tty: ${DOCKER_TTY:-true}
    restart: always
    networks:
      - on-bullmq-redis
    ports:
      - 6379:6379
    command: /bin/sh -c "redis-server --requirepass $$REDIS_PASSWORD --port $$REDIS_PORT --loglevel notice"
    environment: &bullmq-env
      REDIS_PORT: 6379
      REDIS_PASSWORD: local-dev-value
  on-transfer-outbound: &transfer-outbound-service
    image: node-dev:1.0
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./node-dev-docker-env
      dockerfile: ./Dockerfile.node-dev
    volumes:
      - ./transfer-outbound:/home/node-dev/project
      - ./transfer-outbound/.env.node-dev-docker-env-overrides:/home/node-dev/project/.env
    command: npm run dev:${DOCKER_API_COMMAND:-docker} # 'docker' or 'docker-debug'
    networks:
      - gateway
      - on-internal
      - on-bullmq-redis
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      - 3002:3000
      - 9232:9229 # for the node debug server, when active; see node-dev-docker-env/package.json `dev:docker-debug` script
    environment:
      <<: *bullmq-env
      EXPRESS_PORT: 3000
      DEV_IS_LOCAL_ENV: True
      REDIS_HOST: on-bullmq-redis
      FHIR_URL: http://on-fhir:8080/fhir # in this case, resolved inside the container, with container networking

  bc-fhir-db:
    <<: *fhir-db-service
    networks:
      - bc-fhir-db
  bc-fhir:
    <<: *fhir-service
    networks:
      - gateway
      - bc-fhir-db
      - bc-internal
    ports:
      - 8080:8080
    environment:
      <<: *fhir-db-env
      DB_PORT: 5432
      DB_HOST: bc-fhir-db
      FHIR_SERVER_ADDRESS: http://localhost:8080/bc/fhir # see proxy address via gateway.default.conf
  bc-synthesizer:
    <<: *synthesizer-service
    networks:
      - bc-internal
    environment:
      NUM_RECORDS: 100
      PT: bc
      FHIR_URL: http://bc-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  bc-aggregator:
    <<: *aggregator-service
    networks:
      - gateway
      - bc-internal
    environment:
      AGGREGATION_INTERVAL: 60
      FHIR_URL: http://bc-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  bc-patient-browser:
    <<: *patient-browser-service
    networks:
      - gateway
      - bc-internal
    environment:
      FHIR_URL: http://localhost:8080/bc/fhir/ # in this case, resolved in the host browser, not container networking, see gateway.default.conf
  bc-transfer-inbound:
    <<: *transfer-inbound-service
    command: npm run dev # note: only opening debug ports on the ON services
    networks:
      - gateway
      - bc-internal
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      - 3003:3000
    environment:
      FHIR_URL: http://bc-fhir:8080/fhir # in this case, resolved inside the container, with container networking
  bc-bullmq-redis:
    <<: *bullmq-redis
    networks:
      - bc-bullmq-redis
    environment:
      <<: *bullmq-env
  bc-transfer-outbound:
    <<: *transfer-outbound-service
    command: npm run dev # note: only opening debug ports on the ON services
    networks:
      - gateway
      - bc-internal
      - bc-bullmq-redis
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      - 3004:3000
    environment:
      <<: *bullmq-env
      EXPRESS_PORT: 3000
      DEV_IS_LOCAL_ENV: True
      REDIS_HOST: bc-bullmq-redis
      FHIR_URL: http://bc-fhir:8080/fhir # in this case, resolved inside the container, with container networking

  federator:
    image: node-dev:1.0
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./node-dev-docker-env
      dockerfile: ./Dockerfile.node-dev
    volumes:
      - ./federator:/home/node-dev/project
      - ./federator/.env.node-dev-docker-env-overrides:/home/node-dev/project/.env
    command: npm run dev:${DOCKER_API_COMMAND:-docker} # 'docker' or 'docker-debug'
    networks:
      - gateway
      - federal-internal
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      - 3000:3000
      - 9229:9229 # for the node debug server, when active; see node-dev-docker-env/package.json `dev:docker-debug` script
    environment:
      EXPRESS_PORT: 3000
      DEV_IS_LOCAL_ENV: True
      AGGREGATOR_URLS: 'http://gateway/on/aggregator,http://gateway/bc/aggregator'
  dashboard:
    image: rshiny-dashboard:1.0
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./rshiny-dashboard
    networks:
      - gateway
      - federal-internal
    ports:
      - 3838:3838
    environment:
      AGGREGATOR_URL: http://federator:3000/aggregated-data

  demo-portal:
    image: demo-portal:1.3
    tty: ${DOCKER_TTY:-true}
    build:
      context: ./demo-portal
    networks:
      - gateway
    ports:
      - 8080:8080
    environment:
      FED_DASHBOARD_URL: http://localhost:8080/fed/dashboard
      FED_FEDERATOR_URL: http://localhost:8080/fed/federator/aggregated-data
      BC_BROWSER_URL: http://localhost:8080/bc/browser
      BC_FHIR_URL: http://localhost:8080/bc/fhir
      BC_AGGREGATOR_URL: http://localhost:8080/bc/aggregator/aggregated-data
      ON_BROWSER_URL: http://localhost:8080/on/browser
      ON_FHIR_URL: http://localhost:8080/on/fhir
      ON_AGGREGATOR_URL: http://localhost:8080/on/aggregator/aggregated-data
      DEMO_TRANSFER_DASHBOARD_URL: http://localhost:8080/demo-transfer-dashboard
  demo-transfer-dashboard:
    image: node-dev:1.0
    tty: ${DOCKER_TTY:-true}
    restart: always
    build:
      context: ./node-dev-docker-env
      dockerfile: ./Dockerfile.node-dev
    volumes:
      - ./demo-transfer-dashboard:/home/node-dev/project
      - ./demo-transfer-dashboard/.env.node-dev-docker-env-overrides:/home/node-dev/project/.env
    command: npm run dev:${DOCKER_API_COMMAND:-docker} # 'docker' or 'docker-debug'
    networks:
      - gateway
        # node-dev images need to reach the internet for installing packages at run time, and to surface debug servers directly.
        # For docker networking and prod-parity purposes, service-to-service communications should still go through the nginx gateway
      - host-loopback
    ports:
      # configuring the websocket rsbuild uses to send hot reload signals is a bother with out proxy setup. The websockets can still
      # connect, bypassing the nginx proxy, if this container is 1) conntected to the host-loopback and 2) has the same exposed container port
      # (3005 right now) as it serves on internally (see the PORT env var below)
      - 3005:3005
      - 9233:9229 # for the node debug server, when active; see node-dev-docker-env/package.json `dev:docker-debug` script
    environment:
      PORT: 3005
      BASE_PATH: /demo-transfer-dashboard # see docker-compose nginx config, the rsbuild is behind a proxy path, needs to be configured to serve relative to it
      # the demo transfer dashboard will make transfer-outbound API request from the browser, so request must go through the nginx gateway paths
      ON_OUTBOUND_URL: http://localhost:8080/on/outbound
      BC_OUTBOUND_URL: http://localhost:8080/bc/outbound
