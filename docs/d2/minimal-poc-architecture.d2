vars: {
  d2-config: {
    layout-engine: elk
  }
}
direction: right

title: Minimal POC Architecture {
  shape: text
  near: top-center
  style: {
    font-size: 55
    italic: true
  }
}


fhir-synthetic-populator: Synthetic Data Populator {
  icon: ./icons/general/script.svg
  icon.near: bottom-right

  explanation: |md
    Batch population of HAPI FHIR servers with synthetic records via the HAPI FHIR bulk APIs
  |
}

pt-a-boundary: Notional PT A Boundary {
  style: {
    stroke-dash: 3
    fill: transparent
  }

  hapi: FHIR Server {
    style: {
      stroke-dash: 3
      fill: transparent
    }
    
    db: PostgreSQL\nimage {
      shape: cylinder
    }

    server: hapiproject/hapi\nimage {
      icon: ./icons/general/server.svg
      shape: image
    }
    server -> db
  }

  iidi-services: IIDI Services {
    style: {
      stroke-dash: 3
      fill: transparent
    }

    aggregation-service: Aggregation Service {
      icon: ./icons/general/server.svg
      icon.near: bottom-right
  
      explanation: |md
        - Provides an end point to request aggregate data, takes an aggregation time range
        - Validates API token of requestor
        - Fetches and aggregates records from FHIR server on valid request
      |
    }

    transfer-service: Transfer Service {
      icon: ./icons/general/server.svg
      icon.near: bottom-right

      explanation: |md
        - Knows other PTs' transfer service inbound endpoints, has API tokens for them
        - Validates API tokens for each other PT for access to its own inbound endpoint
          - For dev/minimal POC purposes, each PT's tokens can be hard coded
      |

      outbound: Outbound Transfer API {
        shape: step
        explanation: |md
          - REST endpoint that takes a patient ID and and receiving PT, initiates a transfer
          - Collects FHIR records to send (patient, immunization records, adverse reactions, etc. Specifics TBD)
            - assuming minimal set of records/fields in scope, strip anything out of scope
          - Sends bundle to inbound API, waits for response from inbound API
            - on success, flags records in outbound FHIR server as transfered
            - on either success or failure, responds to original transfer requester
        |
      }
      
      inbound: Inbound Transfer API {
        shape: step
        explanation: |md
          - REST endpoint that takes a bundle of inbound FHIR records (patient, immunization records, etc. TBD)
          - Infers outbound PT from the sender's identity
          - Validates incoming records, writes via FHIR bulk API (bulk API probably performs validation already, TBC)
          - Sends success/failure response to outbound PT API
        |
      }
    }
  }
  iidi-services.aggregation-service -> hapi.server: Read
  iidi-services.transfer-service.outbound -> hapi.server: Read
  iidi-services.transfer-service.inbound -> hapi.server: Write
}
pt-a-boundary.hapi.server -> fhir-synthetic-populator

pt-b-boundary: Notional PT B Boundary {
  style: {
    stroke-dash: 3
    fill: transparent
  }

  hapi: FHIR Server {
    style: {
      stroke-dash: 3
      fill: transparent
    }
    
    db: PostgreSQL\nimage {
      shape: cylinder
    }

    server: hapiproject/hapi\nimage {
      icon: ./icons/general/server.svg
      shape: image
    }
    server -> db
  }

  iidi-services: IIDI Services {
    style: {
      stroke-dash: 3
      fill: transparent
    }

    aggregation-service: Aggregation Service {
      icon: ./icons/general/server.svg
      shape: image
    }

    transfer-service: Transfer Service {
      icon: ./icons/general/server.svg
      icon.near: bottom-right

      outbound: Outbound Transfer API {
        shape: step
      }
      
      inbound: Inbound Transfer API {
        shape: step
      }
    }
  }
  iidi-services.aggregation-service -> hapi.server: Read
  iidi-services.transfer-service.outbound -> hapi.server: Read
  iidi-services.transfer-service.inbound -> hapi.server: Write
}
pt-b-boundary.hapi.server -> fhir-synthetic-populator

pt-a-boundary.iidi-services.transfer-service.outbound -> pt-b-boundary.iidi-services.transfer-service.inbound: Transfer
pt-b-boundary.iidi-services.transfer-service.outbound -> pt-a-boundary.iidi-services.transfer-service.inbound: Transfer

federal-boundary: Notional Federal Boundary {
  style: {
    stroke-dash: 3
    fill: transparent
  }

  federated-api: API Federation Server {
    icon: ./icons/general/server.svg
    icon.near: bottom-right

    explanation: |md
      - Knows provincial endpoint URLs, has API access tokens for them (both hardcoded for minimal POC)
      - Provides:
        - End point to request all PT's aggregate data, takes a time range
        - End point to request individual PT's aggregate data, takes a time range
    |
  }
}
federal-boundary.federated-api -> pt-a-boundary.iidi-services.aggregation-service: Federates provincial\naggregation APIs
federal-boundary.federated-api -> pt-b-boundary.iidi-services.aggregation-service: Federates provincial\naggregation APIs

poc-demo-only-boundary: Demo Components {
  style: {
    stroke-dash: 3
    fill: transparent
  }
  
  consumer-dashboard: Demo Consumer Dashboard {
    icon: ./icons/general/server.svg
    icon.near: bottom-right
  
    explanation: |md
      R Shiny dashboard, for demo purposes
    |
  }

  transfer-dashboard: Demo Transfer Dashboard {
    icon: ./icons/general/react.svg
    icon.near: bottom-right

    explanation: |md
      Purely for demonstration purposes, UI for
      intiating and monitoring outbound transfers
    |
  }

  dev: Dev/Demo User {
    icon: ./icons/general/dev.svg
    shape: image
  }
  dev -> consumer-dashboard: Demo Access
  dev -> transfer-dashboard: Demo Access
}
poc-demo-only-boundary.consumer-dashboard -> federal-boundary.federated-api: Get federated data
poc-demo-only-boundary.transfer-dashboard -> pt-a-boundary.iidi-services.transfer-service.outbound: Initiate transfer