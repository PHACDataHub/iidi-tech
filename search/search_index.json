{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to IIDI-Tech Documentation","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>System Components &amp; Architecture</li> <li>PT-to-PT Transfer Data Flow</li> <li>PT-to-PHAC Data Reporting</li> <li>Why IIDI Matters</li> <li>Next Steps</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>The Interoperable Immunization Data Initiative (IIDI) aims to enhance the interoperability of immunization data across various jurisdictions. The initiative involves three pillars of interoperability \u2013 standards, governance and technology. The IIDI Phase 1 Proof of Concept (PoC) focusses on implementing a federated data architecture to enable seamless immunization record transfer and access between jurisdictions and with the Public Health Agency of Canada (PHAC). A federated data-access architecture is designed to facilitate secure, standardized, and real-time immunization data exchange between provincial and federal health systems in Canada. This initiative enables inter-provincial (PT-to-PT) immunization record access and data reporting to PHAC (Public Health Agency of Canada) for national surveillance and analysis.</p> <p>The Phase 1 PoC leverages FHIR-based APIs, Kubernetes-based microservices, Redis for job queuing, and R-Shiny for visualization, ensuring a robust, scalable, and privacy-compliant ecosystem.</p>"},{"location":"#system-components-architecture","title":"System Components &amp; Architecture","text":""},{"location":"#provincial-kubernetes-namespaces-ontario-british-columbia","title":"Provincial Kubernetes Namespaces: Ontario &amp; British Columbia","text":"<p>Each province operates its own Kubernetes namespace, where immunization records are accessed and transferred securely. Key components include:</p> <ul> <li>SMART Patient Viewer: Allows healthcare providers to view immunization records in a FHIR-compliant format.</li> <li>HAPI FHIR Server: Serves as the FHIR repository, enabling data access.</li> <li>FHIR Aggregator Service: Extracts and prepares data for PT-to-PT access and PT-to-PHAC reporting.</li> <li>FHIR Synthesizer: Generates synthetic FHIR data for testing and validation.</li> <li>Redis Queue: Handles asynchronous processing to manage API rate limits and ensure resilience.</li> <li>Transfer Services (Outbound &amp; Inbound): Enable secure retrieval and exchange of immunization records across jurisdictions.</li> </ul> <p>Reference Diagram: </p>"},{"location":"#federal-kubernetes-namespace-phac-federal-data-processing","title":"Federal Kubernetes Namespace: PHAC (Federal Data Processing)","text":"<p>At the federal level, PHAC processes immunization data for national-level analysis. Core services include:</p> <ul> <li>FHIR Federator Service: Receives and normalizes immunization records from multiple provinces.</li> <li>R-Shiny Dashboard: Provides visual insights for public health officials, helping track coverage trends, vaccine uptake, and emerging patterns.</li> </ul>"},{"location":"#pt-to-pt-transfer-data-flow","title":"PT-to-PT Transfer Data Flow","text":""},{"location":"#1-transfer-initiation-ontario-bc","title":"1\ufe0f\u20e3 Transfer Initiation (Ontario \u2192 BC)","text":"<ul> <li>Ontario\u2019s Transfer-Outbound Service retrieves immunization records from the HAPI FHIR Server for a migrating patient.</li> <li>Data is structured in FHIR-compliant JSON format.</li> </ul>"},{"location":"#2-job-queued-in-redis-ontario","title":"2\ufe0f\u20e3 Job Queued in Redis (Ontario)","text":"<ul> <li>The JSON payload is queued in Redis to handle API rate limits and ensure reliable processing.</li> </ul>"},{"location":"#3-secure-data-transfer-ontario-bc","title":"3\ufe0f\u20e3 Secure Data Transfer (Ontario \u2192 BC)","text":"<ul> <li>Ontario\u2019s Transfer-Outbound Service encrypts and transmits the immunization record to BC\u2019s Transfer-Inbound Service via mutual TLS (mTLS).</li> </ul>"},{"location":"#4-transfer-processing-bc-inbound-service","title":"4\ufe0f\u20e3 Transfer Processing (BC Inbound Service)","text":"<ul> <li>BC\u2019s Transfer-Inbound Service verifies API authentication and validates the payload using HL7 FHIR standards.</li> </ul>"},{"location":"#5-immunization-record-access-in-bcs-fhir-repository","title":"5\ufe0f\u20e3 Immunization Record Access in BC\u2019s FHIR Repository","text":"<ul> <li>The immunization record is accessible in BC\u2019s HAPI FHIR Server, ensuring compliance with FHIR guidelines.</li> </ul>"},{"location":"#pt-to-phac-data-reporting","title":"PT-to-PHAC Data Reporting","text":""},{"location":"#1-data-aggregation-from-provincial-systems","title":"1\ufe0f\u20e3 Data Aggregation from Provincial Systems","text":"<ul> <li>Each province\u2019s FHIR Aggregator Service queries the HAPI FHIR Server to retrieve structured immunization records.</li> </ul>"},{"location":"#2-fhir-data-validation-de-identification","title":"2\ufe0f\u20e3 FHIR Data Validation &amp; De-Identification","text":"<ul> <li>The FHIR Aggregator Service processes and de-identifies immunization records.</li> <li>Validation is performed against FHIR standards to ensure accuracy &amp; compliance before federal reporting.</li> </ul>"},{"location":"#3-secure-data-transfer-to-phac","title":"3\ufe0f\u20e3 Secure Data Transfer to PHAC","text":"<ul> <li>Each province\u2019s FHIR Aggregator Service securely transmits records to PHAC\u2019s FHIR Federator Service using:</li> <li>TLS encryption</li> <li>API security policies for protection in transit</li> </ul>"},{"location":"#4-phacs-federator-service-validates-normalizes-data","title":"4\ufe0f\u20e3 PHAC\u2019s Federator Service Validates &amp; Normalizes Data","text":"<ul> <li>The FHIR Federator Service at PHAC:</li> <li>Receives and normalizes records</li> <li>Removes inconsistencies</li> <li>Standardizes FHIR fields from multiple PTs into a unified format</li> </ul>"},{"location":"#5-data-access-via-phacs-federated-data-platform","title":"5\ufe0f\u20e3 Data Access via PHAC\u2019s Federated Data Platform","text":"<ul> <li>Once validated, immunization records are accessible through FHIR APIs for national surveillance &amp; trend analysis.</li> </ul>"},{"location":"#6-immunization-insights-via-r-shiny-dashboard","title":"6\ufe0f\u20e3 Immunization Insights via R-Shiny Dashboard","text":"<ul> <li>Processed data is visualized in R-Shiny Dashboards for:</li> <li>Tracking vaccine trends</li> <li>Identifying coverage gaps</li> <li>Monitoring emerging patterns</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udcc4 Read the Getting Started Guide to set up your environment.</li> <li>\ud83d\udd0d Explore the Architecture Overview.</li> <li>\ud83d\udee0 Check out the API Reference for integration details.</li> </ul>"},{"location":"api/aggregation/","title":"FHIR Immunization Data Aggregation API","text":"<p>The FHIR Immunization Data Aggregation API is a Flask-based service that retrieves, processes, and aggregates immunization data from a FHIR server. This API groups immunization records by key attributes such as:</p> <ul> <li>Occurrence Year</li> <li>Jurisdiction (ON or BC)</li> <li>Sex</li> <li>Age Group</li> <li>Dose Count</li> </ul> <p>This API supports real-time data analysis and reporting for public health monitoring.</p>"},{"location":"api/aggregation/#environment-variables","title":"Environment Variables","text":"<p>The API is configurable using the following environment variables:</p> Variable Description Default <code>FHIR_URL</code> Base URL of the FHIR server <code>http://localhost:8080/fhir</code> <code>AGGREGATION_INTERVAL</code> Time in seconds to cache aggregated data <code>60</code> <code>PUBLIC_KEY_PATH</code> Path to the public key for JWT validation <code>/secrets/public_key.pem</code> <code>IS_LOCAL_DEV</code> Set <code>true</code> to disable authentication in local environments <code>false</code>"},{"location":"api/aggregation/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/aggregation/#1-get-aggregated-immunization-data","title":"1\ufe0f\u20e3 Get Aggregated Immunization Data","text":""},{"location":"api/aggregation/#get-aggregated-data","title":"GET <code>/aggregated-data</code>","text":"<p>Retrieves FHIR-based immunization records, processes them, and returns grouped data.</p>"},{"location":"api/aggregation/#request-headers","title":"Request Headers","text":"Header Description Required <code>Authorization</code> Bearer token for JWT authentication \u2705 (unless <code>IS_LOCAL_DEV = true</code>)"},{"location":"api/aggregation/#response-format","title":"Response Format","text":"<p>Returns aggregated immunization data in JSON format.</p>"},{"location":"api/aggregation/#example-response","title":"Example Response:","text":"<pre><code>[\n  {\n    \"OccurrenceYear\": \"2023\",\n    \"Jurisdiction\": \"ON\",\n    \"Sex\": \"Female\",\n    \"Age\": \"5 years\",\n    \"Dose\": 2,\n    \"Count\": 120,\n    \"ReferenceDate\": \"2023-12-31\"\n  },\n  {\n    \"OccurrenceYear\": \"2023\",\n    \"Jurisdiction\": \"BC\",\n    \"Sex\": \"Male\",\n    \"Age\": \"7 years\",\n    \"Dose\": 1,\n    \"Count\": 95,\n    \"ReferenceDate\": \"2023-12-31\"\n  }\n]\n</code></pre>"},{"location":"api/aggregation/#response-fields","title":"Response Fields","text":"Field Description <code>OccurrenceYear</code> The year the immunization occurred <code>Jurisdiction</code> The province where immunization was recorded <code>Sex</code> The patient's sex <code>Age</code> The patient's age group <code>Dose</code> The dose count for the vaccine <code>Count</code> Number of immunization records in this group <code>ReferenceDate</code> The last day of the occurrence year"},{"location":"api/aggregation/#2-health-check-endpoint","title":"2\ufe0f\u20e3 Health Check Endpoint","text":""},{"location":"api/aggregation/#get-health","title":"GET <code>/health</code>","text":"<p>Returns API health status.</p>"},{"location":"api/aggregation/#response-format_1","title":"Response Format","text":"<pre><code>{\n  \"status\": \"ok\"\n}\n</code></pre>"},{"location":"api/aggregation/#data-processing-workflow","title":"Data Processing Workflow","text":""},{"location":"api/aggregation/#step-1-fetching-fhir-data","title":"Step 1: Fetching FHIR Data","text":"<ul> <li>The API queries the FHIR server for Immunization resources.</li> <li>It paginates through records to retrieve complete datasets.</li> <li>Uses structured logging to monitor data retrieval.</li> </ul>"},{"location":"api/aggregation/#step-2-fetching-patient-data","title":"Step 2: Fetching Patient Data","text":"<ul> <li>The API retrieves Patient resources from FHIR for each immunization record.</li> <li>Uses LRU caching to reduce redundant API calls.</li> </ul>"},{"location":"api/aggregation/#step-3-processing-and-aggregation","title":"Step 3: Processing and Aggregation","text":"<ul> <li>Extracts Jurisdiction, Year, Sex, Age, Dose.</li> <li>Groups data by these attributes.</li> <li>Assigns December 31st as the ReferenceDate.</li> </ul>"},{"location":"api/aggregation/#step-4-caching-authentication","title":"Step 4: Caching &amp; Authentication","text":"<ul> <li>Stores aggregated data for <code>AGGREGATION_INTERVAL</code> seconds.</li> <li>Enforces JWT authentication unless <code>IS_LOCAL_DEV</code> is enabled.</li> <li>Uses a public key for token verification.</li> </ul>"},{"location":"api/aggregation/#security-features","title":"Security Features","text":"<ul> <li>JWT Authentication: Tokens are validated via RSA public keys.</li> <li>Data Protection: No personal identifiers are stored or exposed.</li> <li>Rate Limiting &amp; Caching: Prevents excessive FHIR API calls.</li> <li>Structured Logging: Ensures visibility into API operations.</li> </ul>"},{"location":"api/aggregation/#deployment","title":"Deployment","text":""},{"location":"api/aggregation/#local-development","title":"Local Development","text":"<p>Run the API locally with authentication disabled:</p> <pre><code>export IS_LOCAL_DEV=true\npython app.py\n</code></pre>"},{"location":"api/aggregation/#production-deployment","title":"Production Deployment","text":"<p>Use Gunicorn for scalable deployments:</p> <pre><code>gunicorn -w 4 -b 0.0.0.0:5000 app:app\n</code></pre>"},{"location":"api/federator/","title":"Federator API","text":"<p>The Federator API is an Express-based service designed to retrieve, process, and aggregate data from multiple external sources. The API aggregates the data, validates it, and returns the grouped results to the caller. This service is public, meaning no authentication is required to make requests.</p>"},{"location":"api/federator/#environment-variables","title":"Environment Variables","text":"<p>The API can be configured using the following environment variables:</p> Variable Description Default <code>AGGREGATOR_URLS</code> A comma-separated list of URLs to fetch data from. <code>http://localhost:8080/data</code> <code>PRIVATE_KEY_PATH</code> Path to the private key used for signing JWT tokens for outbound requests (for aggregator communication) <code>/secrets/private_key.pem</code> <code>IS_LOCAL_DEV</code> Set <code>true</code> to disable JWT signing for local development environments <code>false</code> <p>Note: Additional provinces or jurisdictions can be added to the federator by modifying the <code>AGGREGATOR_URLS</code> environment variable. Each province or jurisdiction must have a corresponding external data source endpoint.</p>"},{"location":"api/federator/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/federator/#1-get-aggregated-data","title":"1\ufe0f\u20e3 Get Aggregated Data","text":""},{"location":"api/federator/#get-aggregated-data","title":"GET <code>/aggregated-data</code>","text":"<p>This endpoint retrieves aggregated data from external data sources, validates it, and returns grouped results.</p>"},{"location":"api/federator/#query-parameters","title":"Query Parameters:","text":"<p>None.</p>"},{"location":"api/federator/#request-headers","title":"Request Headers:","text":"Header Description None No authentication required for public API usage."},{"location":"api/federator/#response-format","title":"Response Format:","text":"<ul> <li> <p><code>data</code> (Array): A list of valid aggregated data objects. Each object contains:</p> </li> <li> <p><code>Age</code>: The age group for the data.</p> </li> <li><code>Count</code>: The number of occurrences.</li> <li><code>Dose</code>: The immunization dose count.</li> <li><code>Jurisdiction</code>: The jurisdiction (e.g., ON, BC).</li> <li><code>OccurrenceYear</code>: The year the grouped occurrences took place.</li> <li><code>Sex</code>: The sex of the individuals (e.g., Male, Female, Other) in teh current group.</li> <li> <p><code>ReferenceDate</code>: The reference date for the records in current group.</p> </li> <li> <p><code>errors</code> (Array): A list of error messages for any failed data aggregations. Each error describes the failure reason (e.g., network issues, invalid data format).</p> </li> </ul>"},{"location":"api/federator/#example-response","title":"Example Response:","text":"<pre><code>{\n  \"data\": [\n    {\n      \"Age\": \"15 years\",\n      \"Count\": 5,\n      \"Dose\": 1,\n      \"Jurisdiction\": \"ON\",\n      \"OccurrenceYear\": \"2015\",\n      \"Sex\": \"Female\",\n      \"ReferenceDate\": \"2015-12-31\"\n    },\n    {\n      \"Age\": \"13 years\",\n      \"Count\": 3,\n      \"Dose\": 2,\n      \"Jurisdiction\": \"BC\",\n      \"OccurrenceYear\": \"2016\",\n      \"Sex\": \"Male\",\n      \"ReferenceDate\": \"2016-12-31\"\n    }\n  ],\n  \"errors\": []\n}\n</code></pre>"},{"location":"api/synthesizer/","title":"Synthetic FHIR Data Generator and Uploader","text":"<p>The Synthetic FHIR Data Generator and Uploader is a Python-based script designed to generate synthetic immunization records and upload them to a FHIR server as a transaction bundle. The script supports both British Columbia (BC) and Ontario (ON) jurisdictions and ensures realistic data generation with configurable parameters.</p>"},{"location":"api/synthesizer/#dependencies","title":"Dependencies","text":"<p>This script relies on the following Python libraries:</p> Dependency Purpose <code>requests</code> For making API calls to the FHIR server. <code>faker</code> For generating realistic patient data. <code>logging</code> For structured logging and debugging. <code>os</code> For handling environment variables. <code>random</code> For generating randomized values. <code>datetime</code> For generating randomized dates."},{"location":"api/synthesizer/#environment-variables","title":"Environment Variables","text":"<p>The script behavior can be configured using the following environment variables:</p> Variable Description Default <code>FHIR_URL</code> Base URL of the FHIR server. <code>http://localhost:8080/fhir</code> <code>NUM_RECORDS</code> Number of synthetic immunization records to generate. <code>1</code> <code>PT</code> Province code (<code>bc</code> or <code>on</code>) for jurisdiction logic. <code>bc</code>"},{"location":"api/synthesizer/#key-functions","title":"Key Functions","text":""},{"location":"api/synthesizer/#1-generate-a-random-date","title":"1\ufe0f\u20e3 Generate a Random Date","text":""},{"location":"api/synthesizer/#random_datestart_date-end_date","title":"<code>random_date(start_date, end_date)</code>","text":"<p>Generates a random date within the given range.</p>"},{"location":"api/synthesizer/#2-create-a-patient-resource","title":"2\ufe0f\u20e3 Create a Patient Resource","text":""},{"location":"api/synthesizer/#create_patient_resourcepatient_id","title":"<code>create_patient_resource(patient_id)</code>","text":"<p>Generates a FHIR-compliant Patient resource with:</p> <ul> <li>Randomized demographic details (name, gender, birthdate, address).</li> <li>Unique identifiers (health card number, UUID).</li> <li>Additional metadata (consent status, ethnicity, language, risk factors).</li> </ul>"},{"location":"api/synthesizer/#3-create-an-allergy-resource-only-for-bc-patients","title":"3\ufe0f\u20e3 Create an Allergy Resource (Only for BC Patients)","text":""},{"location":"api/synthesizer/#create_allergy_resourcepatient_id","title":"<code>create_allergy_resource(patient_id)</code>","text":"<p>Generates an AllergyIntolerance resource with:</p> <ul> <li>Random allergy type, criticality, and onset date.</li> <li>SNOMED-CT coding for standardization.</li> <li>FHIR-compliant allergy status and type.</li> </ul>"},{"location":"api/synthesizer/#4-create-an-immunization-resource","title":"4\ufe0f\u20e3 Create an Immunization Resource","text":""},{"location":"api/synthesizer/#create_immunization_resourcepatient_id-birth_date","title":"<code>create_immunization_resource(patient_id, birth_date)</code>","text":"<p>Generates an Immunization resource with:</p> <ul> <li>Vaccine manufacturer, lot number, administration site.</li> <li>Randomized dose count (1 or 2 doses).</li> <li>Occurrence date post first birthday.</li> <li>Optional reaction details (fever).</li> <li>Additional metadata (exemption reasons, concurrent vaccines).</li> </ul>"},{"location":"api/synthesizer/#5-create-a-fhir-transaction-bundle","title":"5\ufe0f\u20e3 Create a FHIR Transaction Bundle","text":""},{"location":"api/synthesizer/#create_transaction_bundlerecords","title":"<code>create_transaction_bundle(records)</code>","text":"<p>Constructs a FHIR-compliant transaction bundle containing:</p> <ul> <li>Patient, Immunization, and Allergy (if applicable) resources.</li> <li>Batch submission format for efficient FHIR API ingestion.</li> </ul>"},{"location":"api/synthesizer/#6-generate-synthetic-records","title":"6\ufe0f\u20e3 Generate Synthetic Records","text":""},{"location":"api/synthesizer/#generate_synthetic_recordsnum_records","title":"<code>generate_synthetic_records(num_records)</code>","text":"<p>Generates a specified number of synthetic patient and immunization records.</p>"},{"location":"api/synthesizer/#7-upload-data-to-fhir-server","title":"7\ufe0f\u20e3 Upload Data to FHIR Server","text":""},{"location":"api/synthesizer/#upload_to_fhir_serverbundle","title":"<code>upload_to_fhir_server(bundle)</code>","text":"<p>Uploads the generated FHIR transaction bundle to the FHIR server.</p> <ul> <li>Implements retry logic for fault tolerance.</li> <li>Logs success or failure messages.</li> </ul>"},{"location":"api/synthesizer/#execution-flow","title":"Execution Flow","text":"<p>1\ufe0f\u20e3 Generates <code>NUM_RECORDS</code> synthetic immunization records. 2\ufe0f\u20e3 Creates a FHIR transaction bundle. 3\ufe0f\u20e3 Uploads the bundle to the specified FHIR server. 4\ufe0f\u20e3 Logs success or failure messages.</p>"},{"location":"api/synthesizer/#api-endpoint-interaction","title":"API Endpoint Interaction","text":"<ul> <li>The script POSTs data to the <code>FHIR_URL</code> via a FHIR transaction bundle.</li> <li>Implements retries for API failures to ensure data delivery.</li> </ul>"},{"location":"api/synthesizer/#example-fhir-patient-resource-generated","title":"Example FHIR Patient Resource (Generated)","text":"<pre><code>{\n  \"resourceType\": \"Patient\",\n  \"id\": \"patient-1\",\n  \"name\": [\n    {\n      \"family\": \"Smith\",\n      \"given\": [\"John\", \"Michael\"]\n    }\n  ],\n  \"gender\": \"male\",\n  \"birthDate\": \"2015-05-20\",\n  \"address\": [\n    {\n      \"line\": [\"123 Fake Street\"],\n      \"city\": \"Vancouver\",\n      \"state\": \"BC\",\n      \"postalCode\": \"V5K 0A1\",\n      \"country\": \"CA\"\n    }\n  ],\n  \"identifier\": [\n    { \"system\": \"http://healthcare.example.org/ids\", \"value\": \"abcd-1234\" },\n    {\n      \"system\": \"http://healthcare.example.org/healthcard\",\n      \"value\": \"9876543210\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/synthesizer/#deployment","title":"Deployment","text":""},{"location":"api/synthesizer/#run-locally","title":"Run Locally","text":"<p>Run the script with authentication disabled for local testing:</p> <pre><code>export IS_LOCAL_DEV=true\npython synthetic_fhir_data.py\n</code></pre>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/","title":"PHAC's Google Cloud Project","text":""},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#explaining-the-network-architecture-for-phacs-google-cloud-project","title":"Explaining the Network Architecture for PHAC\u2019s Google Cloud Project","text":"<p>This architecture represents a secure and scalable cloud-based infrastructure deployed on Google Cloud Platform (GCP) by PHAC (Public Health Agency of Canada). It is designed to ensure secure communication, automated certificate management, and robust protection against cyber threats. Let\u2019s walk through how a user interacts with the system and how their request moves through various components while maintaining security and efficiency.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#user-access-and-dns-resolution","title":"User Access and DNS Resolution","text":"<p>When a user wants to access the application, they type the application\u2019s URL into their browser. Before the request can reach the application, it must first resolve the domain name to an IP address. This is where Cloud DNS comes in. It translates the human-readable domain (e.g., <code>app.example.ca</code>) into a machine-readable IP address, allowing the browser to know where to send the request.</p> <p>Once the domain name is resolved, the browser sends an HTTPS request to the application, ensuring that the communication is encrypted from the start. This is a critical step in protecting user data from being intercepted during transmission.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#traffic-handling-with-load-balancer-and-security-protection","title":"Traffic Handling with Load Balancer and Security Protection","text":"<p>The request is then routed to Google Cloud\u2019s HTTPS Load Balancer, which plays a crucial role in managing and securing incoming traffic. One of its primary responsibilities is terminating TLS (SSL)\u2014essentially, it decrypts the request, allowing the system to process it efficiently before re-encrypting it as needed. Additionally, if a user accidentally accesses the application via HTTP instead of HTTPS, the Load Balancer automatically redirects the request to HTTPS, ensuring that all traffic remains securely encrypted.</p> <p>To further protect against cyber threats, the request is passed through Cloud Armor, Google\u2019s Web Application Firewall (WAF). This layer helps detect and block malicious activities, such as DDoS attacks, SQL injection, and cross-site scripting (XSS). By filtering out harmful requests, Cloud Armor ensures that only legitimate traffic reaches the application.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#routing-traffic-within-google-cloud","title":"Routing Traffic Within Google Cloud","text":"<p>Once the request has been validated and secured, it enters Google Cloud\u2019s Virtual Private Cloud (VPC) within the northamerica-northeast1 (Montreal) region. Here, VPC firewall rules are enforced to control access, ensuring that only authorized traffic is allowed to pass through.</p> <p>The request is then forwarded to a Google Kubernetes Engine (GKE) Autopilot cluster, which is running Anthos Service Mesh. This cluster hosts the application and ensures seamless scaling, allowing the system to handle varying traffic loads efficiently.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#automated-ssltls-certificate-management","title":"Automated SSL/TLS Certificate Management","text":"<p>A key part of this architecture is automated certificate management, which ensures that all communication remains secure. This is achieved using cert-manager, an open-source tool that handles the provisioning, renewal, and application of SSL/TLS certificates.</p> <p>These certificates are issued by Let\u2019s Encrypt, a widely trusted Certificate Authority (CA).</p> <p>With cert-manager, the system can automatically request, renew, and apply TLS certificates and enforce mTLS (mutual TLS) authentication between services. This allows the system to establish encrypted connections between microservices, reducing the risk of expired certificates causing security vulnerabilities. The certificates are stored securely as Kubernetes Secrets.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#ingress-and-end-to-end-service-security-with-istio","title":"Ingress and End-to-End Service Security with Istio","text":"<p>After passing through the network layers, the request is routed to the Istio Ingress Gateway, which serves as a secure entry point into the Kubernetes cluster. This component ensures that all incoming traffic is routed correctly to the appropriate application services.</p> <p>To further enhance security, the architecture enforces mutual TLS (mTLS) for internal service-to-service communication. This means that every interaction between different services within the cluster is both encrypted and authenticated, preventing unauthorized access and ensuring that remote attackers cannot impersonate a service.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#processing-the-request-in-the-application","title":"Processing the Request in the Application","text":"<p>At this stage, the request finally reaches the Application Codebase, where it is processed. Whether it\u2019s retrieving data, performing an action, or responding to a user request, the application ensures that all operations follow strict security policies.</p> <p>Once the application has processed the request, the response is securely sent back through the same protected path\u2014first through the Istio Ingress Gateway, then back to the Load Balancer, and finally to the user\u2019s browser over an encrypted HTTPS connection.</p>"},{"location":"architecture/GCP%20Architecture/GCP-Architecture/#why-this-architecture-matters","title":"Why This Architecture Matters","text":"<p>This system is built with security, automation, and scalability in mind. Every step ensures that:</p> <ul> <li>All data is protected using encryption.</li> <li>Malicious traffic is blocked before it reaches the application.</li> <li>Services communicate securely using mTLS authentication.</li> </ul> <p>By using Google Cloud\u2019s Load Balancer, Cloud Armor, and Anthos Service Mesh, along with automated SSL certificate management via Let\u2019s Encrypt, this system guarantees a modern, cloud-native, and highly secure infrastructure.</p>"},{"location":"architecture/User-Journey-1/User-Journey-1/","title":"Interoperable Immunization Data Initiative (IIDI) \u2013 User Journey 1: PT-to-PT Transfer","text":""},{"location":"architecture/User-Journey-1/User-Journey-1/#technical-architecture-and-implementation-for-secure-cross-provincial-data-exchange","title":"Technical Architecture and Implementation for Secure Cross-Provincial Data Exchange","text":""},{"location":"architecture/User-Journey-1/User-Journey-1/#1-introduction","title":"1. Introduction","text":"<p>The Interoperable Immunization Data Initiative (IIDI) is designed to facilitate a secure, standards-based, and interoperable approach for immunization record exchange across Provincial and Territorial (PT) jurisdictions in Canada. As part of this initiative, User Journey 1 focuses on the technical implementation of PT-to-PT transfers, ensuring a scalable, Kubernetes-native solution that aligns with modern security, compliance, and interoperability best practices.</p> <p>This document provides a comprehensive technical breakdown of the PT-to-PT immunization data exchange, covering system architecture, data flow, security measures, and infrastructure details. It is important to emphasize that this document strictly focuses on the technical aspects of the transfer. Governance, consent frameworks, and policy considerations are explicitly out of scope at this stage, as the assumption is that PTs will handle out-of-band consent and authorization mechanisms prior to initiating a transfer.</p> <p>The technical model assumes a push-based transfer mechanism where the originating PT (data owner) initiates the record transmission only after an external approval process. The system is designed with privacy, security, and reliability in mind, utilizing industry-standard protocols such as FHIR (Fast Healthcare Interoperability Resources), OAuth2, mTLS encryption, and Kubernetes-native deployments.</p>"},{"location":"architecture/User-Journey-1/User-Journey-1/#2-system-architecture","title":"2. System Architecture","text":"<p>The PT-to-PT transfer mechanism is built on a decentralized, API-driven architecture where each PT maintains its own independent namespace within a Kubernetes cluster while adhering to a standardized data exchange model. The architecture is designed to be scalable, secure, and easily extendable, allowing additional provinces to onboard without requiring modifications to the existing infrastructure.</p> <p>Each PT namespace is deployed on Google Kubernetes Engine (GKE) and managed using GitOps best practices through FluxCD and Kustomize. This ensures a declarative, auditable, and version-controlled infrastructure while maintaining a consistent deployment pipeline across multiple jurisdictions.</p> <p>The core architectural components of the PT-to-PT transfer model include the following:</p>"},{"location":"architecture/User-Journey-1/User-Journey-1/#pt-specific-components-ontario-british-columbia-etc","title":"PT-Specific Components (Ontario, British Columbia, etc.)","text":"<p>Each PT namespace consists of the following services, which collectively manage immunization data storage, retrieval, and secure transmission:</p> <ul> <li>HAPI FHIR Server: A FHIR-compliant immunization data repository that serves as the authoritative source for immunization records in each PT.</li> <li>CloudNativePG (CNPG) Database: A high-availability PostgreSQL-based persistence layer, deployed as a Kubernetes-native managed service to store immunization records securely.</li> <li>Redis Cache: A high-performance message queue and caching layer, enabling asynchronous job execution for queued transfer requests, ensuring reliable record transmission.</li> <li>Transfer Services (Outbound and Inbound): Microservices responsible for initiating, processing, and validating data transfers, ensuring compliance with FHIR schema and security policies.</li> </ul>"},{"location":"architecture/User-Journey-1/User-Journey-1/#secure-pt-to-pt-data-exchange-layer","title":"Secure PT-to-PT Data Exchange Layer","text":"<p>To facilitate inter-provincial immunization data exchange, the system relies on a highly secure, API-based transfer model that incorporates:</p> <ul> <li>FHIR RESTful APIs for structured immunization record retrieval and transmission.</li> <li>FHIR Bulk Data APIs for high-volume data exchange, ensuring minimal latency and optimized resource consumption.</li> <li>Asynchronous Processing via Redis to queue and handle transfer requests without blocking system resources.</li> <li>Encryption with mTLS to prevent unauthorized access and data interception.</li> </ul> <p>Each PT operates independently, but standardized interfaces and shared security models ensure seamless interoperability.</p>"},{"location":"architecture/User-Journey-1/User-Journey-1/#3-pt-to-pt-data-transfer-process","title":"3. PT-to-PT Data Transfer Process","text":""},{"location":"architecture/User-Journey-1/User-Journey-1/#31-transfer-workflow","title":"3.1 Transfer Workflow","text":"<p>The PT-to-PT data transfer process follows a structured, stepwise approach to ensure data consistency, security, and regulatory compliance while maintaining operational efficiency.</p> <ol> <li>Initiating the Transfer: When a patient moves or requires immunization records in another jurisdiction, the receiving PT requests the immunization history from the originating PT through an external, policy-driven process.</li> <li>Outbound Transfer Service Execution: The originating PT validates the transfer request, retrieves the relevant immunization records from the HAPI FHIR Server, and structures the data for secure transmission.</li> <li>Secure Data Transmission: The data is queued in Redis, encrypted using mTLS, and transmitted to the receiving PT\u2019s Inbound Transfer Service.</li> <li>Data Validation and Ingestion: The receiving PT validates the incoming data, ensuring compliance with FHIR schema and security policies before persisting it in its local FHIR server.</li> <li>Acknowledgment and Completion: Upon successful ingestion, the receiving PT confirms receipt of the data, completing the transfer.</li> </ol>"},{"location":"architecture/User-Journey-1/User-Journey-1/#4-technical-implementation","title":"4. Technical Implementation","text":""},{"location":"architecture/User-Journey-1/User-Journey-1/#41-outbound-transfer-service","title":"4.1 Outbound Transfer Service","text":"<p>The Outbound Transfer Service acts as the initiator of data transfers and is responsible for:</p> <ul> <li>Retrieving the required immunization records from the local FHIR repository.</li> <li>Validating the transfer request against API security policies.</li> <li>Queuing requests in Redis for optimized handling.</li> <li>Establishing a secure connection with the destination PT via mutual TLS.</li> <li>Encrypting and transmitting the data using the FHIR Bulk Data API.</li> </ul>"},{"location":"architecture/User-Journey-1/User-Journey-1/#42-inbound-transfer-service","title":"4.2 Inbound Transfer Service","text":"<p>The Inbound Transfer Service is responsible for handling incoming immunization records securely and efficiently. It:</p> <ul> <li>Validates the structure and content of the received immunization data.</li> <li>Persists the records in the local FHIR server, ensuring adherence to schema constraints.</li> </ul>"},{"location":"architecture/User-Journey-1/User-Journey-1/#43-redis-as-a-message-queue","title":"4.3 Redis as a Message Queue","text":"<p>To ensure scalability and reliability, Redis is used for:</p> <ul> <li>Managing high-throughput transfer requests efficiently.</li> <li>Providing a fault-tolerant mechanism to handle transfer retries.</li> <li>Ensuring zero data loss by acting as an intermediate buffer before final persistence.</li> </ul>"},{"location":"architecture/User-Journey-1/User-Journey-1/#5-security-and-compliance-considerations","title":"5. Security and Compliance Considerations","text":"<p>Security is a core principle of this design, ensuring that immunization data remains protected during PT-to-PT transfers. The system implements:</p> <ul> <li>End-to-End Encryption: All communications between PTs leverage mTLS for encryption and authentication.</li> <li>Role-Based Access Control (RBAC): Enforces strict least-privilege access for system components.</li> <li>Comprehensive Audit Logging: Every request and response is logged for compliance and forensic analysis.</li> <li>Secure Kubernetes Workloads: All services run in isolated namespaces, ensuring multi-tenancy security best practices.</li> </ul>"},{"location":"architecture/User-Journey-2/User-Journey-2/","title":"Interoperable Immunization Data Initiative (IIDI) \u2013 User Journey 2: PT-to-PHAC","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#technical-architecture-and-implementation-strategy-user-journey-2-pt-to-phac","title":"Technical Architecture and Implementation Strategy User Journey 2 (PT to PHAC)","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#1-introduction","title":"1. Introduction","text":"<p>The Interoperable Immunization Data Initiative (IIDI) is designed to enable secure, federated, and privacy-compliant immunization data sharing between Provincial/Territorial (PT) health systems and the Public Health Agency of Canada (PHAC). This initiative follows a distributed architecture, ensuring that each PT retains full control over its immunization records while allowing for standardized reporting and analytics at the national level.</p> <p>A core principle of IIDI is that PHAC does not access, store, or process personal health information (PHI). Instead, all de-identification and aggregation occur at the PT level before data is transmitted. This ensures that only pre-processed, anonymized immunization summaries are shared with PHAC, aligning with federal and provincial privacy policies.</p> <p>This document provides an in-depth technical breakdown of the IIDI architecture, detailing how Kubernetes, CloudNativePG (CNPG), Flux, Kustomize, GitOps, FHIR, and SMART on FHIR technologies are leveraged to build a scalable, secure, and future-proof immunization data-sharing ecosystem.</p>"},{"location":"architecture/User-Journey-2/User-Journey-2/#2-deployment-architecture-kubernetes-infrastructure","title":"2. Deployment Architecture &amp; Kubernetes Infrastructure","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#21-kubernetes-architecture-and-namespace-isolation","title":"2.1 Kubernetes Architecture and Namespace Isolation","text":"<p>The IIDI infrastructure is fully deployed on Google Kubernetes Engine (GKE) with namespace-based isolation for each participating PT. Each PT operates within its own namespace, containing:</p> <ul> <li>HAPI FHIR Server \u2013 The core immunization record repository.</li> <li>CloudNativePG (CNPG) Database \u2013 A Kubernetes-native PostgreSQL instance for structured immunization data storage.</li> <li>FHIR Aggregation Services \u2013 Microservices for processing and anonymizing immunization data.</li> <li>SMART on FHIR Patient Viewer \u2013 A secure web-based application for browsing FHIR immunization records.</li> </ul> <p>Namespaces are secured using Kubernetes Role-Based Access Control (RBAC), NetworkPolicies, and Anthos Service Mesh (ASM), ensuring that PT workloads are fully isolated.</p>"},{"location":"architecture/User-Journey-2/User-Journey-2/#22-gitops-driven-deployment-with-flux-kustomize","title":"2.2 GitOps-Driven Deployment with Flux &amp; Kustomize","text":"<p>All deployments follow a GitOps model using Flux and Kustomize, ensuring that application configurations remain declarative, version-controlled, and continuously reconciled with production environments.</p> <ul> <li>FluxCD: Automates deployments by continuously monitoring GitHub repositories for configuration changes.</li> <li>Kustomize: Enables environment-specific overlays, allowing PT-specific variations while maintaining a consistent core deployment structure.</li> <li>Cloud Build: Handles CI/CD pipelines, ensuring that image builds, and infrastructure changes are validated before deployment.</li> </ul> <p>This declarative, version-controlled approach ensures that all changes to the system are traceable, reproducible, and securely managed.</p>"},{"location":"architecture/User-Journey-2/User-Journey-2/#3-cloudnativepg-cnpg-for-immunization-data-management","title":"3. CloudNativePG (CNPG) for Immunization Data Management","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#31-why-cloudnativepg","title":"3.1 Why CloudNativePG?","text":"<p>IIDI leverages CloudNativePG (CNPG) as a Kubernetes-native PostgreSQL operator, ensuring high availability, automated failover, and seamless integration with Kubernetes workloads. CNPG was chosen over traditional PostgreSQL deployments because:</p> <ul> <li>It follows the Kubernetes Operator pattern, making PostgreSQL a first-class citizen in Kubernetes.</li> <li>It enables self-healing and automated failover, ensuring high availability without external dependencies.</li> <li>It integrates directly with Kubernetes Secrets, Persistent Volumes, and ConfigMaps for seamless scaling and resilience.</li> </ul>"},{"location":"architecture/User-Journey-2/User-Journey-2/#32-cnpg-database-architecture","title":"3.2 CNPG Database Architecture","text":"<p>Each PT namespace contains its own CNPG database cluster, which stores FHIR-compliant immunization records.</p> <ul> <li>Automated Failover &amp; High Availability: If a primary node fails, CNPG automatically promotes a new primary, ensuring minimal downtime.</li> <li>Streaming Replication &amp; Read Scalability: CNPG supports read-only replicas, optimizing performance for real-time analytics and reporting queries.</li> <li>Rolling Updates &amp; Immutable Containers: PostgreSQL containers are updated using zero-downtime rolling upgrades, ensuring continuous availability.</li> </ul> <p>Access to CNPG is strictly governed via RBAC policies, ensuring that only authorized services (FHIR API, Aggregator, Federator) can query data.</p>"},{"location":"architecture/User-Journey-2/User-Journey-2/#4-immunization-data-processing-aggregation","title":"4. Immunization Data Processing &amp; Aggregation","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#41-synthetic-fhir-data-generation","title":"4.1 Synthetic FHIR Data Generation","text":"<p>Since this phase of the project is a controlled simulation, real patient data is not used. Instead, a Flask-based Kubernetes Job (Synthesizer) generates FHIR-compliant synthetic immunization records.</p> <ul> <li>Uses Faker (Python) to generate realistic FHIR Patient, Immunization, and AllergyIntolerance resources.</li> <li>Uploads the generated data to the HAPI FHIR Server via FHIR transaction bundles.</li> <li>Ensures that FHIR resource structures align with PT-approved schemas, maintaining consistency across jurisdictions.</li> </ul>"},{"location":"architecture/User-Journey-2/User-Journey-2/#42-aggregation-data-standardization","title":"4.2 Aggregation &amp; Data Standardization","text":"<p>Once immunization records are ingested, the Aggregator microservice processes and standardizes data before submitting it to PHAC.</p> <ul> <li>FHIR Data Extraction: Queries the HAPI FHIR Server for Immunization and Patient data.</li> <li>De-identification &amp; Grouping: Data is categorized by:</li> <li>Jurisdiction (BC, ON)</li> <li>Occurrence Year</li> <li>Age Group</li> <li>Sex</li> <li>Vaccine Type</li> <li>Dose</li> <li>API Endpoint (<code>/aggregated-data</code>): Exposes the processed dataset via a REST API, caching results to improve performance.</li> </ul> <p>All aggregation happens within PT namespaces, ensuring that PHAC only receives high-level, de-identified summaries.</p>"},{"location":"architecture/User-Journey-2/User-Journey-2/#5-secure-data-federation-reporting","title":"5. Secure Data Federation &amp; Reporting","text":""},{"location":"architecture/User-Journey-2/User-Journey-2/#51-federated-api-gateway","title":"5.1 Federated API Gateway","text":"<p>Once PT data is aggregated, it is securely transmitted to PHAC via the Federator component.</p> <ul> <li>Role: Serves as an API Gateway, securely routing PT aggregation services to PHAC.</li> <li>Security:</li> <li>Mutual TLS (mTLS) encryption ensures end-to-end security.</li> <li>Ingress controls with fine-grained RBAC ensure minimum-privilege access.</li> </ul>"},{"location":"architecture/User-Journey-2/User-Journey-2/#52-r-shiny-dashboard-for-visualization","title":"5.2 R Shiny Dashboard for Visualization","text":"<ul> <li>Queries the Federator API for real-time immunization insights.</li> <li>Displays statistics per jurisdiction, age group, and vaccine type, supporting national public health monitoring.</li> </ul>"},{"location":"d2/","title":"Architecture","text":""},{"location":"d2/#updating-diagrams","title":"Updating diagrams","text":"<p>The diagram is generated from D2 code to allow versioning and rapid revisions. Install the D2 CLI and the D2 VSCode extension before editing the <code>.d2</code> files.</p> <p>To update a generated svg, <code>cd</code> in to this directory and run <code>d2 &lt;filename&gt;.d2</code>. Add the <code>-w</code> flag for watch mode for a live-updating browser view while editing.</p>"},{"location":"d2/#minimal-poc-architecture","title":"Minimal POC Architecture","text":""},{"location":"ui/ui/","title":"Demo Portal Documentation","text":""},{"location":"ui/ui/#overview","title":"Overview","text":"<p>The Demo Portal is a web application designed to consolidate multiple tools, contextual assumptions, and relevant resources in one platform. Its purpose is to provide a centralized, cohesive user experience, leveraging modern UI and development practices. The portal is built using the GC Design System for UI consistency and accessibility, alongside React for its dynamic, component-driven architecture.</p>"},{"location":"ui/ui/#key-objectives","title":"Key Objectives","text":"<ul> <li>Centralized Access: Consolidates tools, contextual assumptions, and useful links into one platform.</li> <li>Contextual Assumptions: Embeds relevant assumptions and context to support informed tool usage.</li> <li>Resource Links: Provides users with quick access to additional resources and documentation.</li> </ul>"},{"location":"ui/ui/#technology-stack","title":"Technology Stack","text":""},{"location":"ui/ui/#gc-design-system","title":"GC Design System","text":"<p>The portal leverages the Canada Design System by CDS, a comprehensive set of UI guidelines and components designed to ensure consistent and accessible government digital services. By using the CDS, the portal adheres to standard accessibility and usability guidelines for Canadian public sector applications.</p>"},{"location":"ui/ui/#react","title":"React","text":"<p>The Demo Transfer Dashboard utilizes React to create a dynamic, modular interface.</p>"},{"location":"ui/ui/#key-features","title":"Key Features","text":"<ol> <li>Tool Aggregation: The portal serves as a unified interface to showcase and interact with various tools, offering easy navigation and access to each tool's functionalities.</li> <li>Contextual Information: Tools are accompanied by necessary context, assumptions, and usage guidelines to ensure proper understanding.</li> <li>Resource Access: A section dedicated to relevant links provides users with direct access to additional information, related tools, and documentation.</li> <li>Responsive Design: The UI is fully responsive, leveraging the flexibility of React and CDS to ensure consistent behavior across devices.</li> </ol>"},{"location":"ui/ui/#local-setup","title":"Local Setup","text":""},{"location":"ui/ui/#demo-portal","title":"Demo Portal","text":"<p>To run the Demo Portal locally:</p> <p>Navigate to the <code>demo-portal</code> directory:</p> <pre><code>cd .\\demo-portal\n</code></pre> <p>Run the application with the following command:</p> <pre><code>py app.py\n</code></pre>"},{"location":"ui/ui/#demo-transfer-dashboard","title":"Demo Transfer Dashboard","text":"<p>To access the Demo Transfer Dashboard locally:</p> <p>Navigate to the demo-transfer-dashboard directory:</p> <pre><code>cd .\\demo-transfer-dashboard\n</code></pre> <p>Start the development server by running:</p> <pre><code>npm run dev\n</code></pre>"}]}