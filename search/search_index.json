{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to IIDI-Tech Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>The Interoperable Immunization Data Initiative (IIDI) is a federated data-sharing architecture designed to facilitate secure, standardized, and real-time immunization data exchange between provincial and federal health systems in Canada. This initiative enables inter-provincial (PT-to-PT) immunization record transfers and data reporting to PHAC (Public Health Agency of Canada) for national surveillance and analysis.</p> <p>IIDI leverages FHIR-based APIs, Kubernetes-based microservices, Redis for job queuing, and R-Shiny for visualization, ensuring a robust, scalable, and privacy-compliant ecosystem.</p>"},{"location":"#system-components-architecture","title":"System Components &amp; Architecture","text":""},{"location":"#provincial-kubernetes-namespaces-ontario-british-columbia","title":"Provincial Kubernetes Namespaces: Ontario &amp; British Columbia","text":"<p>Each province operates its own Kubernetes namespace, where immunization records are processed and transferred securely. Key components include:</p> <ul> <li>SMART Patient Viewer: Allows healthcare providers to view immunization records in a FHIR-compliant format.</li> <li>HAPI FHIR Server: Serves as the FHIR repository, storing immunization records.</li> <li>Aggregator Service: Extracts and prepares data for PT-to-PT transfers and PT-to-PHAC reporting.</li> <li>Synthesizer: Generates synthetic FHIR data for testing and validation.</li> <li>Redis Queue: Handles asynchronous processing to manage API rate limits and ensure resilience.</li> <li>Transfer Services (Outbound &amp; Inbound): Enable secure transmission of immunization records across jurisdictions.</li> </ul>"},{"location":"#federal-kubernetes-namespace-phac-federal-data-processing","title":"Federal Kubernetes Namespace: PHAC (Federal Data Processing)","text":"<p>At the federal level, PHAC processes immunization data for national-level analysis. Core services include:</p> <ul> <li>Federator Service: Receives and normalizes immunization records from multiple provinces.</li> <li>R-Shiny Dashboard: Provides visual insights for public health officials, helping track coverage trends, vaccine uptake, and emerging patterns.</li> </ul>"},{"location":"#pt-to-pt-transfer-data-flow","title":"PT-to-PT Transfer Data Flow","text":""},{"location":"#1-transfer-initiation-ontario-bc","title":"1 Transfer Initiation (Ontario \u2192 BC)","text":"<ul> <li>Ontario\u2019s Transfer-Outbound Service retrieves immunization records from the HAPI FHIR Server for a migrating patient.</li> <li>Data is structured in FHIR-compliant JSON format.</li> </ul>"},{"location":"#2-job-queued-in-redis-ontario","title":"2 Job Queued in Redis (Ontario)","text":"<ul> <li>The JSON payload is queued in Redis to handle API rate limits and ensure reliable processing.</li> </ul>"},{"location":"#3-secure-data-transfer-ontario-bc","title":"3 Secure Data Transfer (Ontario \u2192 BC)","text":"<ul> <li>Ontario\u2019s Transfer-Outbound Service encrypts and transmits the immunization record to BC\u2019s Transfer-Inbound Service via mutual TLS (mTLS).</li> </ul>"},{"location":"#4-transfer-processing-bc-inbound-service","title":"4 Transfer Processing (BC Inbound Service)","text":"<ul> <li>BC\u2019s Transfer-Inbound Service verifies API authentication and validates the payload using HL7 FHIR standards.</li> </ul>"},{"location":"#5-data-storage-in-bcs-fhir-repository","title":"5 Data Storage in BC\u2019s FHIR Repository","text":"<ul> <li>The immunization record is stored in BC\u2019s HAPI FHIR Server, maintaining data integrity and compliance with FHIR guidelines.</li> </ul>"},{"location":"#pt-to-phac-data-reporting","title":"PT-to-PHAC Data Reporting","text":""},{"location":"#1-data-aggregation-from-provincial-systems","title":"1 Data Aggregation from Provincial Systems","text":"<ul> <li>Each province\u2019s Aggregator Service queries the HAPI FHIR Server to retrieve structured immunization records.</li> </ul>"},{"location":"#2-fhir-data-validation-de-identification","title":"2 FHIR Data Validation &amp; De-Identification","text":"<ul> <li>The Aggregator Service processes and de-identifies immunization records.</li> <li>Validation is performed against FHIR standards to ensure accuracy &amp; compliance before federal reporting.</li> </ul>"},{"location":"#3-secure-data-transfer-to-phac","title":"3 Secure Data Transfer to PHAC","text":"<ul> <li>Each province\u2019s Aggregator Service securely transmits records to PHAC\u2019s Federator Service using:</li> <li>TLS encryption</li> <li>API security policies for protection in transit</li> </ul>"},{"location":"#4-phac-federator-service-validates-normalizes-data","title":"4 PHAC Federator Service Validates &amp; Normalizes Data","text":"<ul> <li>The Federator Service at PHAC:</li> <li>Receives and normalizes records</li> <li>Removes inconsistencies</li> <li>Standardizes FHIR fields from multiple PTs into a unified format</li> </ul>"},{"location":"#5-data-storage-in-phacs-federal-data-platform","title":"5 Data Storage in PHAC\u2019s Federal Data Platform","text":"<ul> <li>Once validated, immunization records are stored in PHAC\u2019s Federated Data Repository for national surveillance &amp; trend analysis.</li> </ul>"},{"location":"#6-immunization-insights-via-r-shiny-dashboard","title":"6 Immunization Insights via R-Shiny Dashboard","text":"<ul> <li>Processed data is visualized in R-Shiny Dashboards for:</li> <li>Tracking vaccine trends</li> <li>Identifying coverage gaps</li> <li>Monitoring emerging patterns</li> </ul>"},{"location":"#why-iidi-matters","title":"Why IIDI Matters","text":"<p>\u2705 Interoperability: Enables seamless immunization record sharing across jurisdictions \u2705 FHIR Standards: Ensures data consistency &amp; compliance \u2705 Security &amp; Privacy: Implements mutual TLS, API authentication, and de-identification \u2705 Scalability: Uses Kubernetes-based microservices &amp; Redis for async processing \u2705 Analytics &amp; Insights: Provides real-time public health intelligence via R-Shiny dashboards</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udcc4 Read the Getting Started Guide to set up your environment.</li> <li>\ud83d\udd0d Explore the Architecture Overview.</li> <li>\ud83d\udee0 Check out the API Reference for integration details.</li> </ul> <p>This documentation provides a comprehensive guide to understanding IIDI\u2019s architecture, data flow, and security model. If you have any questions, refer to the Contributing Guide or reach out to the IIDI Technical Team.</p>"},{"location":"api/aggregation/","title":"FHIR Immunization Data Aggregation API","text":"<p>The FHIR Immunization Data Aggregation API is a Flask-based service that retrieves, processes, and aggregates immunization data from a FHIR server. This API groups immunization records by key attributes such as:</p> <ul> <li>Occurrence Year</li> <li>Jurisdiction (ON or BC)</li> <li>Sex</li> <li>Age Group</li> <li>Dose Count</li> </ul> <p>This API supports real-time data analysis and reporting for public health monitoring.</p>"},{"location":"api/aggregation/#environment-variables","title":"Environment Variables","text":"<p>The API is configurable using the following environment variables:</p> Variable Description Default <code>FHIR_URL</code> Base URL of the FHIR server <code>http://localhost:8080/fhir</code> <code>AGGREGATION_INTERVAL</code> Time in seconds to cache aggregated data <code>60</code> <code>PUBLIC_KEY_PATH</code> Path to the public key for JWT validation <code>/secrets/public_key.pem</code> <code>IS_LOCAL_DEV</code> Set <code>true</code> to disable authentication in local environments <code>false</code>"},{"location":"api/aggregation/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/aggregation/#1-get-aggregated-immunization-data","title":"1\ufe0f\u20e3 Get Aggregated Immunization Data","text":""},{"location":"api/aggregation/#get-aggregated-data","title":"GET <code>/aggregated-data</code>","text":"<p>Retrieves FHIR-based immunization records, processes them, and returns grouped data.</p>"},{"location":"architecture/GCP-Architecture/","title":"PHAC's Google Cloud Project","text":""},{"location":"architecture/GCP-Architecture/#explaining-the-network-architecture-for-phacs-google-cloud-project","title":"Explaining the Network Architecture for PHAC\u2019s Google Cloud Project","text":"<p>This architecture represents a secure and scalable cloud-based infrastructure deployed on Google Cloud Platform (GCP) by PHAC (Public Health Agency of Canada). It is designed to ensure secure communication, automated certificate management, and robust protection against cyber threats. Let\u2019s walk through how a user interacts with the system and how their request moves through various components while maintaining security and efficiency.</p>"},{"location":"architecture/GCP-Architecture/#user-access-and-dns-resolution","title":"User Access and DNS Resolution","text":"<p>When a user wants to access the application, they type the application\u2019s URL into their browser. Before the request can reach the application, it must first resolve the domain name to an IP address. This is where Cloud DNS comes in. It translates the human-readable domain (e.g., <code>app.example.ca</code>) into a machine-readable IP address, allowing the browser to know where to send the request.</p> <p>Once the domain name is resolved, the browser sends an HTTPS request to the application, ensuring that the communication is encrypted from the start. This is a critical step in protecting user data from being intercepted during transmission.</p>"},{"location":"architecture/GCP-Architecture/#traffic-handling-with-load-balancer-and-security-protection","title":"Traffic Handling with Load Balancer and Security Protection","text":"<p>The request is then routed to Google Cloud\u2019s HTTPS Load Balancer, which plays a crucial role in managing and securing incoming traffic. One of its primary responsibilities is terminating TLS (SSL)\u2014essentially, it decrypts the request, allowing the system to process it efficiently before re-encrypting it as needed. Additionally, if a user accidentally accesses the application via HTTP instead of HTTPS, the Load Balancer automatically redirects the request to HTTPS, ensuring that all traffic remains securely encrypted.</p> <p>To further protect against cyber threats, the request is passed through Cloud Armor, Google\u2019s Web Application Firewall (WAF). This layer helps detect and block malicious activities, such as DDoS attacks, SQL injection, and cross-site scripting (XSS). By filtering out harmful requests, Cloud Armor ensures that only legitimate traffic reaches the application.</p>"},{"location":"architecture/GCP-Architecture/#routing-traffic-within-google-cloud","title":"Routing Traffic Within Google Cloud","text":"<p>Once the request has been validated and secured, it enters Google Cloud\u2019s Virtual Private Cloud (VPC) within the northamerica-northeast1 (Montreal) region. Here, VPC firewall rules are enforced to control access, ensuring that only authorized traffic is allowed to pass through.</p> <p>The request is then forwarded to a Google Kubernetes Engine (GKE) Autopilot cluster, which is running Anthos Service Mesh. This cluster hosts the application and ensures seamless scaling, allowing the system to handle varying traffic loads efficiently.</p>"},{"location":"architecture/GCP-Architecture/#automated-ssltls-certificate-management","title":"Automated SSL/TLS Certificate Management","text":"<p>A key part of this architecture is automated certificate management, which ensures that all communication remains secure. This is achieved using cert-manager, an open-source tool that handles the provisioning, renewal, and application of SSL/TLS certificates.</p> <p>These certificates are issued by Let\u2019s Encrypt, a widely trusted Certificate Authority (CA).</p> <p>With cert-manager, the system can automatically request, renew, and apply TLS certificates and enforce mTLS (mutual TLS) authentication between services. This allows the system to establish encrypted connections between microservices, reducing the risk of expired certificates causing security vulnerabilities. The certificates are stored securely as Kubernetes Secrets.</p>"},{"location":"architecture/GCP-Architecture/#ingress-and-end-to-end-service-security-with-istio","title":"Ingress and End-to-End Service Security with Istio","text":"<p>After passing through the network layers, the request is routed to the Istio Ingress Gateway, which serves as a secure entry point into the Kubernetes cluster. This component ensures that all incoming traffic is routed correctly to the appropriate application services.</p> <p>To further enhance security, the architecture enforces mutual TLS (mTLS) for internal service-to-service communication. This means that every interaction between different services within the cluster is both encrypted and authenticated, preventing unauthorized access and ensuring that remote attackers cannot impersonate a service.</p>"},{"location":"architecture/GCP-Architecture/#processing-the-request-in-the-application","title":"Processing the Request in the Application","text":"<p>At this stage, the request finally reaches the Application Codebase, where it is processed. Whether it\u2019s retrieving data, performing an action, or responding to a user request, the application ensures that all operations follow strict security policies.</p> <p>Once the application has processed the request, the response is securely sent back through the same protected path\u2014first through the Istio Ingress Gateway, then back to the Load Balancer, and finally to the user\u2019s browser over an encrypted HTTPS connection.</p>"},{"location":"architecture/GCP-Architecture/#why-this-architecture-matters","title":"Why This Architecture Matters","text":"<p>This system is built with security, automation, and scalability in mind. Every step ensures that:</p> <ul> <li>All data is protected using encryption.</li> <li>Malicious traffic is blocked before it reaches the application.</li> <li>Services communicate securely using mTLS authentication.</li> </ul> <p>By using Google Cloud\u2019s Load Balancer, Cloud Armor, and Anthos Service Mesh, along with automated SSL certificate management via Let\u2019s Encrypt, this system guarantees a modern, cloud-native, and highly secure infrastructure.</p>"},{"location":"architecture/User-Journey-1/","title":"Interoperable Immunization Data Initiative (IIDI) \u2013 User Journey 1: PT-to-PT Transfer","text":""},{"location":"architecture/User-Journey-1/#technical-architecture-and-implementation-for-secure-cross-provincial-data-exchange","title":"Technical Architecture and Implementation for Secure Cross-Provincial Data Exchange","text":""},{"location":"architecture/User-Journey-1/#1-introduction","title":"1. Introduction","text":"<p>The Interoperable Immunization Data Initiative (IIDI) is designed to facilitate a secure, standards-based, and interoperable approach for immunization record exchange across Provincial and Territorial (PT) jurisdictions in Canada. As part of this initiative, User Journey 1 focuses on the technical implementation of PT-to-PT transfers, ensuring a scalable, Kubernetes-native solution that aligns with modern security, compliance, and interoperability best practices.</p> <p>This document provides a comprehensive technical breakdown of the PT-to-PT immunization data exchange, covering system architecture, data flow, security measures, and infrastructure details. It is important to emphasize that this document strictly focuses on the technical aspects of the transfer. Governance, consent frameworks, and policy considerations are explicitly out of scope at this stage, as the assumption is that PTs will handle out-of-band consent and authorization mechanisms prior to initiating a transfer.</p> <p>The technical model assumes a push-based transfer mechanism where the originating PT (data owner) initiates the record transmission only after an external approval process. The system is designed with privacy, security, and reliability in mind, utilizing industry-standard protocols such as FHIR (Fast Healthcare Interoperability Resources), OAuth2, mTLS encryption, and Kubernetes-native deployments.</p>"},{"location":"architecture/User-Journey-1/#2-system-architecture","title":"2. System Architecture","text":"<p>The PT-to-PT transfer mechanism is built on a decentralized, API-driven architecture where each PT maintains its own independent namespace within a Kubernetes cluster while adhering to a standardized data exchange model. The architecture is designed to be scalable, secure, and easily extendable, allowing additional provinces to onboard without requiring modifications to the existing infrastructure.</p> <p>Each PT namespace is deployed on Google Kubernetes Engine (GKE) and managed using GitOps best practices through FluxCD and Kustomize. This ensures a declarative, auditable, and version-controlled infrastructure while maintaining a consistent deployment pipeline across multiple jurisdictions.</p> <p>The core architectural components of the PT-to-PT transfer model include the following:</p>"},{"location":"architecture/User-Journey-1/#pt-specific-components-ontario-british-columbia-etc","title":"PT-Specific Components (Ontario, British Columbia, etc.)","text":"<p>Each PT namespace consists of the following services, which collectively manage immunization data storage, retrieval, and secure transmission:</p> <ul> <li>HAPI FHIR Server: A FHIR-compliant immunization data repository that serves as the authoritative source for immunization records in each PT.</li> <li>CloudNativePG (CNPG) Database: A high-availability PostgreSQL-based persistence layer, deployed as a Kubernetes-native managed service to store immunization records securely.</li> <li>Redis Cache: A high-performance message queue and caching layer, enabling asynchronous job execution for queued transfer requests, ensuring reliable record transmission.</li> <li>Transfer Services (Outbound and Inbound): Microservices responsible for initiating, processing, and validating data transfers, ensuring compliance with FHIR schema and security policies.</li> </ul>"},{"location":"architecture/User-Journey-1/#secure-pt-to-pt-data-exchange-layer","title":"Secure PT-to-PT Data Exchange Layer","text":"<p>To facilitate inter-provincial immunization data exchange, the system relies on a highly secure, API-based transfer model that incorporates:</p> <ul> <li>FHIR RESTful APIs for structured immunization record retrieval and transmission.</li> <li>FHIR Bulk Data APIs for high-volume data exchange, ensuring minimal latency and optimized resource consumption.</li> <li>Asynchronous Processing via Redis to queue and handle transfer requests without blocking system resources.</li> <li>Encryption with mTLS to prevent unauthorized access and data interception.</li> </ul> <p>Each PT operates independently, but standardized interfaces and shared security models ensure seamless interoperability.</p>"},{"location":"architecture/User-Journey-1/#3-pt-to-pt-data-transfer-process","title":"3. PT-to-PT Data Transfer Process","text":""},{"location":"architecture/User-Journey-1/#31-transfer-workflow","title":"3.1 Transfer Workflow","text":"<p>The PT-to-PT data transfer process follows a structured, stepwise approach to ensure data consistency, security, and regulatory compliance while maintaining operational efficiency.</p> <ol> <li>Initiating the Transfer: When a patient moves or requires immunization records in another jurisdiction, the receiving PT requests the immunization history from the originating PT through an external, policy-driven process.</li> <li>Outbound Transfer Service Execution: The originating PT validates the transfer request, retrieves the relevant immunization records from the HAPI FHIR Server, and structures the data for secure transmission.</li> <li>Secure Data Transmission: The data is queued in Redis, encrypted using mTLS, and transmitted to the receiving PT\u2019s Inbound Transfer Service.</li> <li>Data Validation and Ingestion: The receiving PT validates the incoming data, ensuring compliance with FHIR schema and security policies before persisting it in its local FHIR server.</li> <li>Acknowledgment and Completion: Upon successful ingestion, the receiving PT confirms receipt of the data, completing the transfer.</li> </ol>"},{"location":"architecture/User-Journey-1/#4-technical-implementation","title":"4. Technical Implementation","text":""},{"location":"architecture/User-Journey-1/#41-outbound-transfer-service","title":"4.1 Outbound Transfer Service","text":"<p>The Outbound Transfer Service acts as the initiator of data transfers and is responsible for:</p> <ul> <li>Retrieving the required immunization records from the local FHIR repository.</li> <li>Validating the transfer request against API security policies.</li> <li>Queuing requests in Redis for optimized handling.</li> <li>Establishing a secure connection with the destination PT via mutual TLS.</li> <li>Encrypting and transmitting the data using the FHIR Bulk Data API.</li> </ul>"},{"location":"architecture/User-Journey-1/#42-inbound-transfer-service","title":"4.2 Inbound Transfer Service","text":"<p>The Inbound Transfer Service is responsible for handling incoming immunization records securely and efficiently. It:</p> <ul> <li>Validates the structure and content of the received immunization data.</li> <li>Persists the records in the local FHIR server, ensuring adherence to schema constraints.</li> </ul>"},{"location":"architecture/User-Journey-1/#43-redis-as-a-message-queue","title":"4.3 Redis as a Message Queue","text":"<p>To ensure scalability and reliability, Redis is used for:</p> <ul> <li>Managing high-throughput transfer requests efficiently.</li> <li>Providing a fault-tolerant mechanism to handle transfer retries.</li> <li>Ensuring zero data loss by acting as an intermediate buffer before final persistence.</li> </ul>"},{"location":"architecture/User-Journey-1/#5-security-and-compliance-considerations","title":"5. Security and Compliance Considerations","text":"<p>Security is a core principle of this design, ensuring that immunization data remains protected during PT-to-PT transfers. The system implements:</p> <ul> <li>End-to-End Encryption: All communications between PTs leverage mTLS for encryption and authentication.</li> <li>Role-Based Access Control (RBAC): Enforces strict least-privilege access for system components.</li> <li>Comprehensive Audit Logging: Every request and response is logged for compliance and forensic analysis.</li> <li>Secure Kubernetes Workloads: All services run in isolated namespaces, ensuring multi-tenancy security best practices.</li> </ul> <p></p>"},{"location":"architecture/User-Journey-2/","title":"Interoperable Immunization Data Initiative (IIDI) \u2013 User Journey 2: PT-to-PHAC","text":""},{"location":"architecture/User-Journey-2/#technical-architecture-and-implementation-strategy-user-journey-2-pt-to-phac","title":"Technical Architecture and Implementation Strategy User Journey 2 (PT to PHAC)","text":""},{"location":"architecture/User-Journey-2/#1-introduction","title":"1. Introduction","text":"<p>The Interoperable Immunization Data Initiative (IIDI) is designed to enable secure, federated, and privacy-compliant immunization data sharing between Provincial/Territorial (PT) health systems and the Public Health Agency of Canada (PHAC). This initiative follows a distributed architecture, ensuring that each PT retains full control over its immunization records while allowing for standardized reporting and analytics at the national level.</p> <p>A core principle of IIDI is that PHAC does not access, store, or process personal health information (PHI). Instead, all de-identification and aggregation occur at the PT level before data is transmitted. This ensures that only pre-processed, anonymized immunization summaries are shared with PHAC, aligning with federal and provincial privacy policies.</p> <p>This document provides an in-depth technical breakdown of the IIDI architecture, detailing how Kubernetes, CloudNativePG (CNPG), Flux, Kustomize, GitOps, FHIR, and SMART on FHIR technologies are leveraged to build a scalable, secure, and future-proof immunization data-sharing ecosystem.</p>"},{"location":"architecture/User-Journey-2/#2-deployment-architecture-kubernetes-infrastructure","title":"2. Deployment Architecture &amp; Kubernetes Infrastructure","text":""},{"location":"architecture/User-Journey-2/#21-kubernetes-architecture-and-namespace-isolation","title":"2.1 Kubernetes Architecture and Namespace Isolation","text":"<p>The IIDI infrastructure is fully deployed on Google Kubernetes Engine (GKE) with namespace-based isolation for each participating PT. Each PT operates within its own namespace, containing:</p> <ul> <li>HAPI FHIR Server \u2013 The core immunization record repository.</li> <li>CloudNativePG (CNPG) Database \u2013 A Kubernetes-native PostgreSQL instance for structured immunization data storage.</li> <li>FHIR Aggregation Services \u2013 Microservices for processing and anonymizing immunization data.</li> <li>SMART on FHIR Patient Viewer \u2013 A secure web-based application for browsing FHIR immunization records.</li> </ul> <p>Namespaces are secured using Kubernetes Role-Based Access Control (RBAC), NetworkPolicies, and Anthos Service Mesh (ASM), ensuring that PT workloads are fully isolated.</p>"},{"location":"architecture/User-Journey-2/#22-gitops-driven-deployment-with-flux-kustomize","title":"2.2 GitOps-Driven Deployment with Flux &amp; Kustomize","text":"<p>All deployments follow a GitOps model using Flux and Kustomize, ensuring that application configurations remain declarative, version-controlled, and continuously reconciled with production environments.</p> <ul> <li>FluxCD: Automates deployments by continuously monitoring GitHub repositories for configuration changes.</li> <li>Kustomize: Enables environment-specific overlays, allowing PT-specific variations while maintaining a consistent core deployment structure.</li> <li>Cloud Build: Handles CI/CD pipelines, ensuring that image builds, and infrastructure changes are validated before deployment.</li> </ul> <p>This declarative, version-controlled approach ensures that all changes to the system are traceable, reproducible, and securely managed.</p>"},{"location":"architecture/User-Journey-2/#3-cloudnativepg-cnpg-for-immunization-data-management","title":"3. CloudNativePG (CNPG) for Immunization Data Management","text":""},{"location":"architecture/User-Journey-2/#31-why-cloudnativepg","title":"3.1 Why CloudNativePG?","text":"<p>IIDI leverages CloudNativePG (CNPG) as a Kubernetes-native PostgreSQL operator, ensuring high availability, automated failover, and seamless integration with Kubernetes workloads. CNPG was chosen over traditional PostgreSQL deployments because:</p> <ul> <li>It follows the Kubernetes Operator pattern, making PostgreSQL a first-class citizen in Kubernetes.</li> <li>It enables self-healing and automated failover, ensuring high availability without external dependencies.</li> <li>It integrates directly with Kubernetes Secrets, Persistent Volumes, and ConfigMaps for seamless scaling and resilience.</li> </ul>"},{"location":"architecture/User-Journey-2/#32-cnpg-database-architecture","title":"3.2 CNPG Database Architecture","text":"<p>Each PT namespace contains its own CNPG database cluster, which stores FHIR-compliant immunization records.</p> <ul> <li>Automated Failover &amp; High Availability: If a primary node fails, CNPG automatically promotes a new primary, ensuring minimal downtime.</li> <li>Streaming Replication &amp; Read Scalability: CNPG supports read-only replicas, optimizing performance for real-time analytics and reporting queries.</li> <li>Rolling Updates &amp; Immutable Containers: PostgreSQL containers are updated using zero-downtime rolling upgrades, ensuring continuous availability.</li> </ul> <p>Access to CNPG is strictly governed via RBAC policies, ensuring that only authorized services (FHIR API, Aggregator, Federator) can query data.</p>"},{"location":"architecture/User-Journey-2/#4-immunization-data-processing-aggregation","title":"4. Immunization Data Processing &amp; Aggregation","text":""},{"location":"architecture/User-Journey-2/#41-synthetic-fhir-data-generation","title":"4.1 Synthetic FHIR Data Generation","text":"<p>Since this phase of the project is a controlled simulation, real patient data is not used. Instead, a Flask-based Kubernetes Job (Synthesizer) generates FHIR-compliant synthetic immunization records.</p> <ul> <li>Uses Faker (Python) to generate realistic FHIR Patient, Immunization, and AllergyIntolerance resources.</li> <li>Uploads the generated data to the HAPI FHIR Server via FHIR transaction bundles.</li> <li>Ensures that FHIR resource structures align with PT-approved schemas, maintaining consistency across jurisdictions.</li> </ul>"},{"location":"architecture/User-Journey-2/#42-aggregation-data-standardization","title":"4.2 Aggregation &amp; Data Standardization","text":"<p>Once immunization records are ingested, the Aggregator microservice processes and standardizes data before submitting it to PHAC.</p> <ul> <li>FHIR Data Extraction: Queries the HAPI FHIR Server for Immunization and Patient data.</li> <li>De-identification &amp; Grouping: Data is categorized by:</li> <li>Jurisdiction (BC, ON)</li> <li>Occurrence Year</li> <li>Age Group</li> <li>Sex</li> <li>Vaccine Type</li> <li>Dose</li> <li>API Endpoint (<code>/aggregated-data</code>): Exposes the processed dataset via a REST API, caching results to improve performance.</li> </ul> <p>All aggregation happens within PT namespaces, ensuring that PHAC only receives high-level, de-identified summaries.</p>"},{"location":"architecture/User-Journey-2/#5-secure-data-federation-reporting","title":"5. Secure Data Federation &amp; Reporting","text":""},{"location":"architecture/User-Journey-2/#51-federated-api-gateway","title":"5.1 Federated API Gateway","text":"<p>Once PT data is aggregated, it is securely transmitted to PHAC via the Federator component.</p> <ul> <li>Role: Serves as an API Gateway, securely routing PT aggregation services to PHAC.</li> <li>Security:</li> <li>Mutual TLS (mTLS) encryption ensures end-to-end security.</li> <li>Ingress controls with fine-grained RBAC ensure minimum-privilege access.</li> </ul>"},{"location":"architecture/User-Journey-2/#52-r-shiny-dashboard-for-visualization","title":"5.2 R Shiny Dashboard for Visualization","text":"<ul> <li>Queries the Federator API for real-time immunization insights.</li> <li>Displays statistics per jurisdiction, age group, and vaccine type, supporting national public health monitoring.</li> </ul>"},{"location":"d2/","title":"Architecture","text":""},{"location":"d2/#updating-diagrams","title":"Updating diagrams","text":"<p>The diagram is generated from D2 code to allow versioning and rapid revisions. Install the D2 CLI and the D2 VSCode extension before editing the <code>.d2</code> files.</p> <p>To update a generated svg, <code>cd</code> in to this directory and run <code>d2 &lt;filename&gt;.d2</code>. Add the <code>-w</code> flag for watch mode for a live-updating browser view while editing.</p>"},{"location":"d2/#minimal-poc-architecture","title":"Minimal POC Architecture","text":""}]}